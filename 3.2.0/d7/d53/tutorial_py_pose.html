<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenCV: Pose Estimation</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d6/d00/tutorial_py_root.html">OpenCV-Python Tutorials</a></li><li class="navelem"><a class="el" href="../../d9/db7/tutorial_py_table_of_contents_calib3d.html">Camera Calibration and 3D Reconstruction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Pose Estimation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<p>In this section,</p><ul>
<li>We will learn to exploit calib3d module to create some 3D effects in images.</li>
</ul>
<h2>Basics </h2>
<p>This is going to be a small section. During the last session on camera calibration, you have found the camera matrix, distortion coefficients etc. Given a pattern image, we can utilize the above information to calculate its pose, or how the object is situated in space, like how it is rotated, how it is displaced etc. For a planar object, we can assume Z=0, such that, the problem now becomes how camera is placed in space to see our pattern image. So, if we know how the object lies in the space, we can draw some 2D diagrams in it to simulate the 3D effect. Let's see how to do it.</p>
<p>Our problem is, we want to draw our 3D coordinate axis (X, Y, Z axes) on our chessboard's first corner. X axis in blue color, Y axis in green color and Z axis in red color. So in-effect, Z axis should feel like it is perpendicular to our chessboard plane.</p>
<p>First, let's load the camera matrix and distortion coefficients from the previous calibration result. </p><div class="fragment"><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"></div><div class="line"><span class="comment"># Load previously saved data</span></div><div class="line">with np.load(<span class="stringliteral">&#39;B.npz&#39;</span>) <span class="keyword">as</span> X:</div><div class="line">    mtx, dist, _, _ = [X[i] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> (<span class="stringliteral">&#39;mtx&#39;</span>,<span class="stringliteral">&#39;dist&#39;</span>,<span class="stringliteral">&#39;rvecs&#39;</span>,<span class="stringliteral">&#39;tvecs&#39;</span>)]</div></div><!-- fragment --><p> Now let's create a function, draw which takes the corners in the chessboard (obtained using <b><a class="el" href="../../d9/d0c/group__calib3d.html#ga93efa9b0aa890de240ca32b11253dd4a" title="Finds the positions of internal corners of the chessboard. ">cv2.findChessboardCorners()</a></b>) and <b>axis points</b> to draw a 3D axis. </p><div class="fragment"><div class="line"><span class="keyword">def </span>draw(img, corners, imgpts):</div><div class="line">    corner = tuple(corners[0].ravel())</div><div class="line">    img = cv2.line(img, corner, tuple(imgpts[0].ravel()), (255,0,0), 5)</div><div class="line">    img = cv2.line(img, corner, tuple(imgpts[1].ravel()), (0,255,0), 5)</div><div class="line">    img = cv2.line(img, corner, tuple(imgpts[2].ravel()), (0,0,255), 5)</div><div class="line">    <span class="keywordflow">return</span> img</div></div><!-- fragment --><p> Then as in previous case, we create termination criteria, object points (3D points of corners in chessboard) and axis points. Axis points are points in 3D space for drawing the axis. We draw axis of length 3 (units will be in terms of chess square size since we calibrated based on that size). So our X axis is drawn from (0,0,0) to (3,0,0), so for Y axis. For Z axis, it is drawn from (0,0,0) to (0,0,-3). Negative denotes it is drawn towards the camera. </p><div class="fragment"><div class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)</div><div class="line">objp = np.zeros((6*7,3), np.float32)</div><div class="line">objp[:,:2] = np.mgrid[0:7,0:6].T.reshape(-1,2)</div><div class="line"></div><div class="line">axis = np.float32([[3,0,0], [0,3,0], [0,0,-3]]).<a class="code" href="../../df/d57/namespacecv_1_1dnn.html#aa9bcba2c9744c31a9ab671a43e192984">reshape</a>(-1,3)</div></div><!-- fragment --><p> Now, as usual, we load each image. Search for 7x6 grid. If found, we refine it with subcorner pixels. Then to calculate the rotation and translation, we use the function, <b><a class="el" href="../../d9/d0c/group__calib3d.html#ga50620f0e26e02caa2e9adc07b5fbf24e" title="Finds an object pose from 3D-2D point correspondences using the RANSAC scheme. ">cv2.solvePnPRansac()</a></b>. Once we those transformation matrices, we use them to project our <b>axis points</b> to the image plane. In simple words, we find the points on image plane corresponding to each of (3,0,0),(0,3,0),(0,0,3) in 3D space. Once we get them, we draw lines from the first corner to each of these points using our draw() function. Done !!! </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> fname <span class="keywordflow">in</span> glob.glob(<span class="stringliteral">&#39;left*.jpg&#39;</span>):</div><div class="line">    img = cv2.imread(fname)</div><div class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</div><div class="line">    ret, corners = cv2.findChessboardCorners(gray, (7,6),<span class="keywordtype">None</span>)</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ret == <span class="keyword">True</span>:</div><div class="line">        corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)</div><div class="line"></div><div class="line">        <span class="comment"># Find the rotation and translation vectors.</span></div><div class="line">        ret,rvecs, tvecs, inliers = cv2.solvePnP(objp, corners2, mtx, dist)</div><div class="line"></div><div class="line">        <span class="comment"># project 3D points to image plane</span></div><div class="line">        imgpts, jac = cv2.projectPoints(axis, rvecs, tvecs, mtx, dist)</div><div class="line"></div><div class="line">        img = draw(img,corners2,imgpts)</div><div class="line">        cv2.imshow(<span class="stringliteral">&#39;img&#39;</span>,img)</div><div class="line">        k = cv2.waitKey(0) &amp; 0xFF</div><div class="line">        <span class="keywordflow">if</span> k == ord(<span class="stringliteral">&#39;s&#39;</span>):</div><div class="line">            cv2.imwrite(fname[:6]+<span class="stringliteral">&#39;.png&#39;</span>, img)</div><div class="line"></div><div class="line">cv2.destroyAllWindows()</div></div><!-- fragment --><p> See some results below. Notice that each axis is 3 squares long.:</p>
<div class="image">
<img src="../../pose_1.jpg" alt="pose_1.jpg"/>
<div class="caption">
image</div></div>
 <h3>Render a Cube</h3>
<p>If you want to draw a cube, modify the draw() function and axis points as follows.</p>
<p>Modified draw() function: </p><div class="fragment"><div class="line"><span class="keyword">def </span>draw(img, corners, imgpts):</div><div class="line">    imgpts = np.int32(imgpts).<a class="code" href="../../df/d57/namespacecv_1_1dnn.html#aa9bcba2c9744c31a9ab671a43e192984">reshape</a>(-1,2)</div><div class="line"></div><div class="line">    <span class="comment"># draw ground floor in green</span></div><div class="line">    img = cv2.drawContours(img, [imgpts[:4]],-1,(0,255,0),-3)</div><div class="line"></div><div class="line">    <span class="comment"># draw pillars in blue color</span></div><div class="line">    <span class="keywordflow">for</span> i,j <span class="keywordflow">in</span> zip(range(4),range(4,8)):</div><div class="line">        img = cv2.line(img, tuple(imgpts[i]), tuple(imgpts[j]),(255),3)</div><div class="line"></div><div class="line">    <span class="comment"># draw top layer in red color</span></div><div class="line">    img = cv2.drawContours(img, [imgpts[4:]],-1,(0,0,255),3)</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> img</div></div><!-- fragment --><p> Modified axis points. They are the 8 corners of a cube in 3D space: </p><div class="fragment"><div class="line">axis = np.float32([[0,0,0], [0,3,0], [3,3,0], [3,0,0],</div><div class="line">                   [0,0,-3],[0,3,-3],[3,3,-3],[3,0,-3] ])</div></div><!-- fragment --><p> And look at the result below:</p>
<div class="image">
<img src="../../pose_2.jpg" alt="pose_2.jpg"/>
<div class="caption">
image</div></div>
<p> If you are interested in graphics, augmented reality etc, you can use OpenGL to render more complicated figures.</p>
<h2>Additional Resources </h2>
<h2>Exercises </h2>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2016 13:00:24 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
