<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenCV: cv::ppf_match_3d::ICP Class Reference</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/d75/namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="../../d0/de6/namespacecv_1_1ppf__match__3d.html">ppf_match_3d</a></li><li class="navelem"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html">ICP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d4/d4c/classcv_1_1ppf__match__3d_1_1ICP-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cv::ppf_match_3d::ICP Class Reference<div class="ingroups"><a class="el" href="../../d9/d25/group__surface__matching.html">Surface Matching</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a very efficient and robust variant of the iterative closest point (<a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a>) algorithm. The task is to register a 3D model (or point cloud) against a set of noisy target data. The variants are put together by myself after certain tests. The task is to be able to match partial, noisy point clouds in cluttered scenes, quickly. You will find that my emphasis is on the performance, while retaining the accuracy. This implementation is based on Tolga Birdal's MATLAB implementation in here: <a href="http://www.mathworks.com/matlabcentral/fileexchange/47152-icp-registration-using-efficient-variants-and-multi-resolution-scheme">http://www.mathworks.com/matlabcentral/fileexchange/47152-icp-registration-using-efficient-variants-and-multi-resolution-scheme</a> The main contributions come from:  
 <a href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#details">More...</a></p>

<p><code>#include &quot;icp.hpp&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad4ea8ec16ca8fc34d7160cfa0b558ae9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9">ICP_SAMPLING_TYPE</a> { <br />
&#160;&#160;<a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9a5779cc8b98ed4d1c8468007c5873123a">ICP_SAMPLING_TYPE_UNIFORM</a>, 
<br />
&#160;&#160;<a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9aa3247323abf8483272eadee8a26f7dff">ICP_SAMPLING_TYPE_GELFAND</a>
<br />
 }</td></tr>
<tr class="separator:ad4ea8ec16ca8fc34d7160cfa0b558ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7290e1a410e32ace65046c4c047c7b7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#a7290e1a410e32ace65046c4c047c7b7e">ICP</a> ()</td></tr>
<tr class="separator:a7290e1a410e32ace65046c4c047c7b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f3672a64b7308ee07e8f856a235d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#a232f3672a64b7308ee07e8f856a235d6">ICP</a> (const int iterations, const float tolerence=0.05, const float rejectionScale=2.5, const int numLevels=6, const <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9">ICP_SAMPLING_TYPE</a> sampleType=<a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9a5779cc8b98ed4d1c8468007c5873123a">ICP_SAMPLING_TYPE_UNIFORM</a>, const int numMaxCorr=1)</td></tr>
<tr class="memdesc:a232f3672a64b7308ee07e8f856a235d6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a> constructor with default arguments.  <a href="#a232f3672a64b7308ee07e8f856a235d6">More...</a><br /></td></tr>
<tr class="separator:a232f3672a64b7308ee07e8f856a235d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3797f4199a713ecf4c869db1830333cd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#a3797f4199a713ecf4c869db1830333cd">~ICP</a> ()</td></tr>
<tr class="separator:a3797f4199a713ecf4c869db1830333cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f6bee97ff92989978a7bf51f7e3431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#a30f6bee97ff92989978a7bf51f7e3431">registerModelToScene</a> (const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;srcPC, const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;dstPC, double &amp;residual, double pose[16])</td></tr>
<tr class="memdesc:a30f6bee97ff92989978a7bf51f7e3431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform registration.  <a href="#a30f6bee97ff92989978a7bf51f7e3431">More...</a><br /></td></tr>
<tr class="separator:a30f6bee97ff92989978a7bf51f7e3431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45e66bf4453badc77a4b0e1524673cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ab45e66bf4453badc77a4b0e1524673cf">registerModelToScene</a> (const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;srcPC, const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;dstPC, std::vector&lt; <a class="el" href="../../d9/d25/group__surface__matching.html#gaace349a5dbee5aa24dd68d8f57518902">Pose3DPtr</a> &gt; &amp;poses)</td></tr>
<tr class="memdesc:ab45e66bf4453badc77a4b0e1524673cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform registration with multiple initial poses.  <a href="#ab45e66bf4453badc77a4b0e1524673cf">More...</a><br /></td></tr>
<tr class="separator:ab45e66bf4453badc77a4b0e1524673cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a very efficient and robust variant of the iterative closest point (<a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a>) algorithm. The task is to register a 3D model (or point cloud) against a set of noisy target data. The variants are put together by myself after certain tests. The task is to be able to match partial, noisy point clouds in cluttered scenes, quickly. You will find that my emphasis is on the performance, while retaining the accuracy. This implementation is based on Tolga Birdal's MATLAB implementation in here: <a href="http://www.mathworks.com/matlabcentral/fileexchange/47152-icp-registration-using-efficient-variants-and-multi-resolution-scheme">http://www.mathworks.com/matlabcentral/fileexchange/47152-icp-registration-using-efficient-variants-and-multi-resolution-scheme</a> The main contributions come from: </p>
<ol type="1">
<li>Picky <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a>: <a href="http://www5.informatik.uni-erlangen.de/Forschung/Publikationen/2003/Zinsser03-ARI.pdf">http://www5.informatik.uni-erlangen.de/Forschung/Publikationen/2003/Zinsser03-ARI.pdf</a></li>
<li>Efficient variants of the <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a> <a class="el" href="../../d3/d46/classcv_1_1Algorithm.html" title="This is a base class for all more or less complex algorithms in OpenCV. ">Algorithm</a>: <a href="http://docs.happycoders.org/orgadoc/graphics/imaging/fasticp_paper.pdf">http://docs.happycoders.org/orgadoc/graphics/imaging/fasticp_paper.pdf</a></li>
<li>Geometrically Stable Sampling for the <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a> <a class="el" href="../../d3/d46/classcv_1_1Algorithm.html" title="This is a base class for all more or less complex algorithms in OpenCV. ">Algorithm</a>: <a href="https://graphics.stanford.edu/papers/stabicp/stabicp.pdf">https://graphics.stanford.edu/papers/stabicp/stabicp.pdf</a></li>
<li>Multi-resolution registration: <a href="http://www.cvl.iis.u-tokyo.ac.jp/~oishi/Papers/Alignment/Jost_MultiResolutionICP_3DIM03.pdf">http://www.cvl.iis.u-tokyo.ac.jp/~oishi/Papers/Alignment/Jost_MultiResolutionICP_3DIM03.pdf</a></li>
<li>Linearization of Point-to-Plane metric by Kok Lim Low: <a href="https://www.comp.nus.edu.sg/~lowkl/publications/lowk_point-to-plane_icp_techrep.pdf">https://www.comp.nus.edu.sg/~lowkl/publications/lowk_point-to-plane_icp_techrep.pdf</a> </li>
</ol>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad4ea8ec16ca8fc34d7160cfa0b558ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ea8ec16ca8fc34d7160cfa0b558ae9">&sect;&nbsp;</a></span>ICP_SAMPLING_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9">cv::ppf_match_3d::ICP::ICP_SAMPLING_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad4ea8ec16ca8fc34d7160cfa0b558ae9a5779cc8b98ed4d1c8468007c5873123a"></a>ICP_SAMPLING_TYPE_UNIFORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad4ea8ec16ca8fc34d7160cfa0b558ae9aa3247323abf8483272eadee8a26f7dff"></a>ICP_SAMPLING_TYPE_GELFAND&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7290e1a410e32ace65046c4c047c7b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7290e1a410e32ace65046c4c047c7b7e">&sect;&nbsp;</a></span>ICP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ppf_match_3d::ICP::ICP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3797f4199a713ecf4c869db1830333cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3797f4199a713ecf4c869db1830333cd">&sect;&nbsp;</a></span>~ICP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual cv::ppf_match_3d::ICP::~ICP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a232f3672a64b7308ee07e8f856a235d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232f3672a64b7308ee07e8f856a235d6">&sect;&nbsp;</a></span>ICP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::ppf_match_3d::ICP::ICP </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>tolerence</em> = <code>0.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>rejectionScale</em> = <code>2.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numLevels</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9">ICP_SAMPLING_TYPE</a>&#160;</td>
          <td class="paramname"><em>sampleType</em> = <code><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html#ad4ea8ec16ca8fc34d7160cfa0b558ae9a5779cc8b98ed4d1c8468007c5873123a">ICP_SAMPLING_TYPE_UNIFORM</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numMaxCorr</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a> constructor with default arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerence</td><td>Controls the accuracy of registration at each iteration of <a class="el" href="../../dc/d9b/classcv_1_1ppf__match__3d_1_1ICP.html" title="This class implements a very efficient and robust variant of the iterative closest point (ICP) algori...">ICP</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rejectionScale</td><td>Robust outlier rejection is applied for robustness. This value actually corresponds to the standard deviation coefficient. Points with rejectionScale * &amp;sigma are ignored during registration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLevels</td><td>Number of pyramid levels to proceed. Deep pyramids increase speed but decrease accuracy. Too coarse pyramids might have computational overhead on top of the inaccurate registrtaion. This parameter should be chosen to optimize a balance. Typical values range from 4 to 10. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleType</td><td>Currently this parameter is ignored and only uniform sampling is applied. Leave it as 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numMaxCorr</td><td>Currently this parameter is ignored and only PickyICP is applied. Leave it as 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a30f6bee97ff92989978a7bf51f7e3431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f6bee97ff92989978a7bf51f7e3431">&sect;&nbsp;</a></span>registerModelToScene() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::ppf_match_3d::ICP::registerModelToScene </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pose</em>[16]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform registration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPC</td><td>The input point cloud for the model. Expected to have the normals (Nx6). Currently, CV_32F is the only supported data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPC</td><td>The input point cloud for the scene. It is assumed that the model is registered on the scene. Scene remains static. Expected to have the normals (Nx6). Currently, CV_32F is the only supported data type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">residual</td><td>The output registration error. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pose</td><td>Transformation between srcPC and dstPC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successful termination, the function returns 0.</dd></dl>
<p>It is assumed that the model is registered on the scene. Scene remains static, while the model transforms. The output poses transform the models onto the scene. Because of the point to plane minimization, the scene is expected to have the normals available. Expected to have the normals (Nx6). </p>

</div>
</div>
<a id="ab45e66bf4453badc77a4b0e1524673cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45e66bf4453badc77a4b0e1524673cf">&sect;&nbsp;</a></span>registerModelToScene() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::ppf_match_3d::ICP::registerModelToScene </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>srcPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"><em>dstPC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d9/d25/group__surface__matching.html#gaace349a5dbee5aa24dd68d8f57518902">Pose3DPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform registration with multiple initial poses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">srcPC</td><td>The input point cloud for the model. Expected to have the normals (Nx6). Currently, CV_32F is the only supported data type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dstPC</td><td>The input point cloud for the scene. Currently, CV_32F is the only supported data type. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">poses</td><td>Input poses to start with but also list output of poses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On successful termination, the function returns 0.</dd></dl>
<p>It is assumed that the model is registered on the scene. Scene remains static, while the model transforms. The output poses transform the models onto the scene. Because of the point to plane minimization, the scene is expected to have the normals available. Expected to have the normals (Nx6). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/build/master-contrib_docs-lin64/opencv_contrib/modules/surface_matching/include/opencv2/surface_matching/<a class="el" href="../../d3/d94/icp_8hpp.html">icp.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2016 13:00:29 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
