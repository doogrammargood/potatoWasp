<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenCV: cv::Ptr&lt; T &gt; Struct Template Reference</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/d75/namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/de1/structcv_1_1Ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cv::Ptr&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="../../d0/de1/group__core.html">Core functionality</a> &raquo; <a class="el" href="../../dc/d84/group__core__basic.html">Basic structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Template class for smart pointers with shared ownership.  
 <a href="../../d0/de7/structcv_1_1Ptr.html#details">More...</a></p>

<p><code>#include &quot;cvstd.hpp&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a62fe84229cc13c10910507a0b5c5ed8b"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a62fe84229cc13c10910507a0b5c5ed8b">element_type</a></td></tr>
<tr class="separator:a62fe84229cc13c10910507a0b5c5ed8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85cbac0b7613df0999cea5b6250e7851"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a85cbac0b7613df0999cea5b6250e7851">Ptr</a> ()</td></tr>
<tr class="separator:a85cbac0b7613df0999cea5b6250e7851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7df1b18cbb91c6ce000ab6ed223a28"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:aeb7df1b18cbb91c6ce000ab6ed223a28"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#aeb7df1b18cbb91c6ce000ab6ed223a28">Ptr</a> (Y *p)</td></tr>
<tr class="separator:aeb7df1b18cbb91c6ce000ab6ed223a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a5da806454bc09695752bd428c4b8"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename D &gt; </td></tr>
<tr class="memitem:a051a5da806454bc09695752bd428c4b8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a051a5da806454bc09695752bd428c4b8">Ptr</a> (Y *p, D d)</td></tr>
<tr class="separator:a051a5da806454bc09695752bd428c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7488a8da83aff1cd90ecd02065abe257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a7488a8da83aff1cd90ecd02065abe257">Ptr</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> &amp;o)</td></tr>
<tr class="separator:a7488a8da83aff1cd90ecd02065abe257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4c6991a08635f89a787edb3d0b7364"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a8c4c6991a08635f89a787edb3d0b7364"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a8c4c6991a08635f89a787edb3d0b7364">Ptr</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;o)</td></tr>
<tr class="separator:a8c4c6991a08635f89a787edb3d0b7364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f6d4d471cd64a853e275d5bf30907c"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ad9f6d4d471cd64a853e275d5bf30907c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#ad9f6d4d471cd64a853e275d5bf30907c">Ptr</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;o, T *p)</td></tr>
<tr class="separator:ad9f6d4d471cd64a853e275d5bf30907c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267e7ea8d5c7bd435131b77af0a64ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a2267e7ea8d5c7bd435131b77af0a64ec">~Ptr</a> ()</td></tr>
<tr class="separator:a2267e7ea8d5c7bd435131b77af0a64ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321bbb47e912dd3f6cf7733a286bb0f4"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a321bbb47e912dd3f6cf7733a286bb0f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a321bbb47e912dd3f6cf7733a286bb0f4">constCast</a> () const</td></tr>
<tr class="separator:a321bbb47e912dd3f6cf7733a286bb0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f3b16ca0fa11727d8daee52b6402e"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a141f3b16ca0fa11727d8daee52b6402e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a141f3b16ca0fa11727d8daee52b6402e">dynamicCast</a> () const</td></tr>
<tr class="separator:a141f3b16ca0fa11727d8daee52b6402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e">empty</a> () const</td></tr>
<tr class="separator:a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77ede1f78274936050b4cfc018c5711"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#ab77ede1f78274936050b4cfc018c5711">get</a> () const</td></tr>
<tr class="separator:ab77ede1f78274936050b4cfc018c5711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020943728a309b2daab5267b3f099c21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a020943728a309b2daab5267b3f099c21">operator T*</a> () const</td></tr>
<tr class="separator:a020943728a309b2daab5267b3f099c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b9298493960e90c5ae6fc5b4e7e78b"><td class="memItemLeft" align="right" valign="top">detail::RefOrVoid&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a44b9298493960e90c5ae6fc5b4e7e78b">operator*</a> () const</td></tr>
<tr class="separator:a44b9298493960e90c5ae6fc5b4e7e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b39661830d8942ce5157b2afee04bba"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a9b39661830d8942ce5157b2afee04bba">operator-&gt;</a> () const</td></tr>
<tr class="separator:a9b39661830d8942ce5157b2afee04bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468377d212f11a2501dcb3fab37955cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a468377d212f11a2501dcb3fab37955cd">operator=</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> &amp;o)</td></tr>
<tr class="separator:a468377d212f11a2501dcb3fab37955cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57120cfa2424b2da090081ffaa2ab36"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:af57120cfa2424b2da090081ffaa2ab36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#af57120cfa2424b2da090081ffaa2ab36">operator=</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;o)</td></tr>
<tr class="separator:af57120cfa2424b2da090081ffaa2ab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f39adf60242c644dd7434b0444bbb08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a6f39adf60242c644dd7434b0444bbb08">release</a> ()</td></tr>
<tr class="separator:a6f39adf60242c644dd7434b0444bbb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8100350b806a4e664cbec3445b8d30a0"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a8100350b806a4e664cbec3445b8d30a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a8100350b806a4e664cbec3445b8d30a0">reset</a> (Y *p)</td></tr>
<tr class="separator:a8100350b806a4e664cbec3445b8d30a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d19fbe9a12af272a82ea021d18d97e"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename D &gt; </td></tr>
<tr class="memitem:a38d19fbe9a12af272a82ea021d18d97e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a38d19fbe9a12af272a82ea021d18d97e">reset</a> (Y *p, D d)</td></tr>
<tr class="separator:a38d19fbe9a12af272a82ea021d18d97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b31a5315638c99ab7ba69c2f86b3a8b"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a2b31a5315638c99ab7ba69c2f86b3a8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a2b31a5315638c99ab7ba69c2f86b3a8b">staticCast</a> () const</td></tr>
<tr class="separator:a2b31a5315638c99ab7ba69c2f86b3a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce9b80e2b7d25daac74fc528228a0f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a4ce9b80e2b7d25daac74fc528228a0f3">swap</a> (<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> &amp;o)</td></tr>
<tr class="separator:a4ce9b80e2b7d25daac74fc528228a0f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a88451fd4df98e8d9f813a7938e12194c"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a88451fd4df98e8d9f813a7938e12194c"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a88451fd4df98e8d9f813a7938e12194c">Ptr</a></td></tr>
<tr class="separator:a88451fd4df98e8d9f813a7938e12194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct cv::Ptr&lt; T &gt;</h3>

<p>Template class for smart pointers with shared ownership. </p>
<p>A <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>&lt;T&gt; pretends to be a pointer to an object of type T. Unlike an ordinary pointer, however, the object will be automatically cleaned up once all <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instances pointing to it are destroyed.</p>
<p><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> is similar to boost::shared_ptr that is part of the Boost library (<a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm</a>) and std::shared_ptr from the <a href="http://en.wikipedia.org/wiki/C++11">C++11</a> standard.</p>
<p>This class provides the following advantages:</p><ul>
<li>Default constructor, copy constructor, and assignment operator for an arbitrary C++ class or C structure. For some objects, like files, windows, mutexes, sockets, and others, a copy constructor or an assignment operator are difficult to define. For some other objects, like complex classifiers in OpenCV, copy constructors are absent and not easy to implement. Finally, some of complex OpenCV and your own data structures may be written in C. However, copy constructors and default constructors can simplify programming a lot. Besides, they are often required (for example, by STL containers). By using a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to such an object instead of the object itself, you automatically get all of the necessary constructors and the assignment operator.</li>
<li><em>O(1)</em> complexity of the above-mentioned operations. While some structures, like std::vector, provide a copy constructor and an assignment operator, the operations may take a considerable amount of time if the data structures are large. But if the structures are put into a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>, the overhead is small and independent of the data size.</li>
<li>Automatic and customizable cleanup, even for C structures. See the example below with FILE*.</li>
<li>Heterogeneous collections of objects. The standard STL and most other C++ and OpenCV containers can store only objects of the same type and the same size. The classical solution to store objects of different types in the same container is to store pointers to the base class (Base*) instead but then you lose the automatic memory management. Again, by using <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>&lt;Base&gt; instead of raw pointers, you can solve the problem.</li>
</ul>
<p>A <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> is said to <em>own</em> a pointer - that is, for each <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> there is a pointer that will be deleted once all <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instances that own it are destroyed. The owned pointer may be null, in which case nothing is deleted. Each <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> also <em>stores</em> a pointer. The stored pointer is the pointer the <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> pretends to be; that is, the one you get when you use <a class="el" href="../../d0/de7/structcv_1_1Ptr.html#ab77ede1f78274936050b4cfc018c5711">Ptr::get</a> or the conversion to T*. It's usually the same as the owned pointer, but if you use casts or the general shared-ownership constructor, the two may diverge: the <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> will still own the original pointer, but will itself point to something else.</p>
<p>The owned pointer is treated as a black box. The only thing <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> needs to know about it is how to delete it. This knowledge is encapsulated in the <em>deleter</em> - an auxiliary object that is associated with the owned pointer and shared between all <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instances that own it. The default deleter is an instance of DefaultDeleter, which uses the standard C++ delete operator; as such it will work with any pointer allocated with the standard new operator.</p>
<p>However, if the pointer must be deleted in a different way, you must specify a custom deleter upon <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> construction. A deleter is simply a callable object that accepts the pointer as its sole argument. For example, if you want to wrap FILE, you may do so as follows: </p><div class="fragment"><div class="line">Ptr&lt;FILE&gt; f(fopen(<span class="stringliteral">&quot;myfile.txt&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>), <a class="code" href="../../d6/d91/modelConvert_8m.html#a43e1302fd7717ad20b65cd664f4b52f8">fclose</a>);</div><div class="line"><span class="keywordflow">if</span>(!f) <span class="keywordflow">throw</span> ...;</div><div class="line"><a class="code" href="../../d6/d91/modelConvert_8m.html#a365159ccfa16c9d2b0bf280a84252a49">fprintf</a>(f, ....);</div><div class="line">...</div><div class="line"><span class="comment">// the file will be closed automatically by f&#39;s destructor.</span></div></div><!-- fragment --><p> Alternatively, if you want all pointers of a particular type to be deleted the same way, you can specialize DefaultDeleter&lt;T&gt;::operator() for that type, like this: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a> {</div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keywordtype">void</span> DefaultDeleter&lt;FILE&gt;::operator ()(FILE * obj)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">    <a class="code" href="../../d6/d91/modelConvert_8m.html#a43e1302fd7717ad20b65cd664f4b52f8">fclose</a>(obj);</div><div class="line">}</div><div class="line">}</div></div><!-- fragment --><p> For convenience, the following types from the OpenCV C API already have such a specialization that calls the appropriate release function:</p><ul>
<li>CvCapture</li>
<li>CvFileStorage</li>
<li><a class="el" href="../../d6/d3d/structCvHaarClassifierCascade.html">CvHaarClassifierCascade</a></li>
<li><a class="el" href="../../d3/db2/structCvMat.html">CvMat</a></li>
<li><a class="el" href="../../d4/d4c/structCvMatND.html">CvMatND</a></li>
<li><a class="el" href="../../db/d76/structCvMemStorage.html">CvMemStorage</a></li>
<li><a class="el" href="../../dd/d4b/structCvSparseMat.html">CvSparseMat</a></li>
<li>CvVideoWriter</li>
<li><a class="el" href="../../d6/d5b/structIplImage.html">IplImage</a> <dl class="section note"><dt>Note</dt><dd>The shared ownership mechanism is implemented with reference counting. As such, cyclic ownership (e.g. when object a contains a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to object b, which contains a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to object a) will lead to all involved objects never being cleaned up. Avoid such situations. </dd>
<dd>
It is safe to concurrently read (but not write) a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instance from multiple threads and therefore it is normally safe to use it in multi-threaded applications. The same is true for <a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">Mat</a> and other C++ OpenCV classes that use internal reference counts. </dd></dl>
</li>
</ul>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="../../d1/d9e/fld_lines_8cpp-example.html#_a7">fld_lines.cpp</a>, <a class="el" href="../../d2/d7b/houghlines_8cpp-example.html#_a20">houghlines.cpp</a>, <a class="el" href="../../d8/dd4/lsd_lines_8cpp-example.html#_a8">lsd_lines.cpp</a>, and <a class="el" href="../../dd/d9d/segment_objects_8cpp-example.html#_a21">segment_objects.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a62fe84229cc13c10910507a0b5c5ed8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fe84229cc13c10910507a0b5c5ed8b">&sect;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a62fe84229cc13c10910507a0b5c5ed8b">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic programming support. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a85cbac0b7613df0999cea5b6250e7851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cbac0b7613df0999cea5b6250e7851">&sect;&nbsp;</a></span>Ptr() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default constructor creates a null <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> - one that owns and stores a null pointer. </p>

</div>
</div>
<a id="aeb7df1b18cbb91c6ce000ab6ed223a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7df1b18cbb91c6ce000ab6ed223a28">&sect;&nbsp;</a></span>Ptr() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If p is null, these are equivalent to the default constructor. Otherwise, these constructors assume ownership of p - that is, the created <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> owns and stores p and assumes it is the sole owner of it. Don't use them if p is already owned by another <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>, or else p will get deleted twice. With the first constructor, DefaultDeleter&lt;Y&gt;() becomes the associated deleter (so p will eventually be deleted with the standard delete operator). Y must be a complete type at the point of invocation. With the second constructor, d becomes the associated deleter. Y* must be convertible to T*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to own. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is often easier to use makePtr instead. </dd></dl>

</div>
</div>
<a id="a051a5da806454bc09695752bd428c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051a5da806454bc09695752bd428c4b8">&sect;&nbsp;</a></span>Ptr() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Deleter to use for the owned pointer. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to own. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7488a8da83aff1cd90ecd02065abe257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7488a8da83aff1cd90ecd02065abe257">&sect;&nbsp;</a></span>Ptr() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These constructors create a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> that shares ownership with another <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> - that is, own the same pointer as o. With the first two, the same pointer is stored, as well; for the second, Y* must be convertible to T*. With the third, p is stored, and Y may be any type. This constructor allows to have completely unrelated owned and stored pointers, and should be used with care to avoid confusion. A relatively benign use is to create a non-owning <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>, like this: </p><div class="fragment"><div class="line">ptr = Ptr&lt;T&gt;(Ptr&lt;T&gt;(), dont_delete_me); <span class="comment">// owns nothing; will not delete the pointer.</span></div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to share ownership with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c4c6991a08635f89a787edb3d0b7364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4c6991a08635f89a787edb3d0b7364">&sect;&nbsp;</a></span>Ptr() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to share ownership with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9f6d4d471cd64a853e275d5bf30907c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f6d4d471cd64a853e275d5bf30907c">&sect;&nbsp;</a></span>Ptr() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to share ownership with. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2267e7ea8d5c7bd435131b77af0a64ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2267e7ea8d5c7bd435131b77af0a64ec">&sect;&nbsp;</a></span>~Ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::~<a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor is equivalent to calling <a class="el" href="../../d0/de7/structcv_1_1Ptr.html#a6f39adf60242c644dd7434b0444bbb08">Ptr::release</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a321bbb47e912dd3f6cf7733a286bb0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321bbb47e912dd3f6cf7733a286bb0f4">&sect;&nbsp;</a></span>constCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;Y&gt; <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::constCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ditto for const_cast. </p>

</div>
</div>
<a id="a141f3b16ca0fa11727d8daee52b6402e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141f3b16ca0fa11727d8daee52b6402e">&sect;&nbsp;</a></span>dynamicCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;Y&gt; <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::dynamicCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ditto for dynamic_cast. </p>

</div>
</div>
<a id="a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0d36c4d05ed9f4fb2a63c5ce9f2c9e">&sect;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ptr.empty() is equivalent to <code>!ptr.<a class="el" href="../../d0/de7/structcv_1_1Ptr.html#ab77ede1f78274936050b4cfc018c5711">get()</a></code>. </p>

</div>
</div>
<a id="ab77ede1f78274936050b4cfc018c5711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77ede1f78274936050b4cfc018c5711">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stored pointer. </p>

</div>
</div>
<a id="a020943728a309b2daab5267b3f099c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020943728a309b2daab5267b3f099c21">&sect;&nbsp;</a></span>operator T*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::operator T* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to <a class="el" href="../../d0/de7/structcv_1_1Ptr.html#ab77ede1f78274936050b4cfc018c5711">get()</a>. </p>

</div>
</div>
<a id="a44b9298493960e90c5ae6fc5b4e7e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b9298493960e90c5ae6fc5b4e7e78b">&sect;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::RefOrVoid&lt;T&gt;::type <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordinary pointer emulation. </p>

</div>
</div>
<a id="a9b39661830d8942ce5157b2afee04bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b39661830d8942ce5157b2afee04bba">&sect;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ordinary pointer emulation. </p>

</div>
</div>
<a id="a468377d212f11a2501dcb3fab37955cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468377d212f11a2501dcb3fab37955cd">&sect;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&amp; <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment replaces the current <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instance with one that owns and stores same pointers as o and then destroys the old instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to share ownership with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af57120cfa2424b2da090081ffaa2ab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57120cfa2424b2da090081ffaa2ab36">&sect;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&amp; <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6f39adf60242c644dd7434b0444bbb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f39adf60242c644dd7434b0444bbb08">&sect;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If no other <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> instance owns the owned pointer, deletes it with the associated deleter. Then sets both the owned and the stored pointers to NULL. </p>

</div>
</div>
<a id="a8100350b806a4e664cbec3445b8d30a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8100350b806a4e664cbec3445b8d30a0">&sect;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>ptr.reset(...)</code> is equivalent to <code>ptr = <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a>&lt;T&gt;(...)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to own. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38d19fbe9a12af272a82ea021d18d97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d19fbe9a12af272a82ea021d18d97e">&sect;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Deleter to use for the owned pointer. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to own. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b31a5315638c99ab7ba69c2f86b3a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b31a5315638c99ab7ba69c2f86b3a8b">&sect;&nbsp;</a></span>staticCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;Y&gt; <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::staticCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> that owns the same pointer as this, and stores the same pointer as this, except converted via static_cast to Y*. </p>

</div>
</div>
<a id="a4ce9b80e2b7d25daac74fc528228a0f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce9b80e2b7d25daac74fc528228a0f3">&sect;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">cv::Ptr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the owned and stored pointers (and deleters, if any) of this and o. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td><a class="el" href="../../d0/de7/structcv_1_1Ptr.html" title="Template class for smart pointers with shared ownership. ">Ptr</a> to swap with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a88451fd4df98e8d9f813a7938e12194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88451fd4df98e8d9f813a7938e12194c">&sect;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>core/include/opencv2/core/<a class="el" href="../../dd/dc7/cvstd_8hpp.html">cvstd.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2016 13:00:27 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
