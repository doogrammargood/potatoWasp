<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenCV: Scene Text Detection</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Scene Text Detection<div class="ingroups"><a class="el" href="../../d4/d61/group__text.html">Scene Text Detection and Recognition</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">cv::text::ERFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]. :  <a href="../../da/def/classcv_1_1text_1_1ERFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html">cv::text::ERStat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html" title="The ERStat structure represents a class-specific Extremal Region (ER). ">ERStat</a> structure represents a class-specific Extremal Region (ER).  <a href="../../db/d20/structcv_1_1text_1_1ERStat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadb54af888e64e7371eae98f54584db3b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="../../da/d56/group__text__detect.html#ggadb54af888e64e7371eae98f54584db3ba79e06bd9ad5b17411581ac430f805e66">cv::text::ERFILTER_NM_RGBLGrad</a>, 
<br />
&#160;&#160;<a class="el" href="../../da/d56/group__text__detect.html#ggadb54af888e64e7371eae98f54584db3ba00b4e765bdc40567ad70beb7df464e06">cv::text::ERFILTER_NM_IHSGrad</a>
<br />
 }<tr class="memdesc:gadb54af888e64e7371eae98f54584db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computeNMChannels operation modes  <a href="../../da/d56/group__text__detect.html#gadb54af888e64e7371eae98f54584db3b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gadb54af888e64e7371eae98f54584db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71e4c8addcf8f6dabc9b6da401d5eb9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#gac71e4c8addcf8f6dabc9b6da401d5eb9">cv::text::erGrouping_Modes</a> { <br />
&#160;&#160;<a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62">cv::text::ERGROUPING_ORIENTATION_HORIZ</a>, 
<br />
&#160;&#160;<a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9aa88b048d788f8f61bcec6c478078e3c4">cv::text::ERGROUPING_ORIENTATION_ANY</a>
<br />
 }<tr class="memdesc:gac71e4c8addcf8f6dabc9b6da401d5eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">text::erGrouping operation modes  <a href="../../da/d56/group__text__detect.html#gac71e4c8addcf8f6dabc9b6da401d5eb9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gac71e4c8addcf8f6dabc9b6da401d5eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga23fdd9364be7b67d104f814dd679fcde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga23fdd9364be7b67d104f814dd679fcde">cv::text::computeNMChannels</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> _src, <a class="el" href="../../dc/d84/group__core__basic.html#ga889a09549b98223016170d9b613715de">OutputArrayOfArrays</a> _channels, int _mode=<a class="el" href="../../da/d56/group__text__detect.html#ggadb54af888e64e7371eae98f54584db3ba79e06bd9ad5b17411581ac430f805e66">ERFILTER_NM_RGBLGrad</a>)</td></tr>
<tr class="memdesc:ga23fdd9364be7b67d104f814dd679fcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the different channels to be processed independently in the N&amp;M algorithm [Neumann12].  <a href="../../da/d56/group__text__detect.html#ga23fdd9364be7b67d104f814dd679fcde">More...</a><br /></td></tr>
<tr class="separator:ga23fdd9364be7b67d104f814dd679fcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e6b32cc3db805155ab51dcd7bc61d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga34e6b32cc3db805155ab51dcd7bc61d5">cv::text::createERFilterNM1</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt; &amp;cb, int thresholdDelta=1, float minArea=(float) 0.00025, float maxArea=(float) 0.13, float minProbability=(float) 0.4, bool nonMaxSuppression=true, float minProbabilityDiff=(float) 0.1)</td></tr>
<tr class="memdesc:ga34e6b32cc3db805155ab51dcd7bc61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Extremal Region Filter for the 1st stage classifier of N&amp;M algorithm [Neumann12].  <a href="../../da/d56/group__text__detect.html#ga34e6b32cc3db805155ab51dcd7bc61d5">More...</a><br /></td></tr>
<tr class="separator:ga34e6b32cc3db805155ab51dcd7bc61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f010f5b65cc60d1290a76807d39c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga00f010f5b65cc60d1290a76807d39c95">cv::text::createERFilterNM2</a> (const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt; &amp;cb, float minProbability=(float) 0.3)</td></tr>
<tr class="memdesc:ga00f010f5b65cc60d1290a76807d39c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Extremal Region Filter for the 2nd stage classifier of N&amp;M algorithm [Neumann12].  <a href="../../da/d56/group__text__detect.html#ga00f010f5b65cc60d1290a76807d39c95">More...</a><br /></td></tr>
<tr class="separator:ga00f010f5b65cc60d1290a76807d39c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4abe0243775e0d1a871a7d85fde0198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#gac4abe0243775e0d1a871a7d85fde0198">cv::text::detectRegions</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> image, const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt; &amp;er_filter1, const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt; &amp;er_filter2, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt; &amp;regions)</td></tr>
<tr class="separator:gac4abe0243775e0d1a871a7d85fde0198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6299380bbb9141488220bdee62b62cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga6299380bbb9141488220bdee62b62cd1">cv::text::erGrouping</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> img, <a class="el" href="../../dc/d84/group__core__basic.html#ga606feabe3b50ab6838f1ba89727aa07a">InputArrayOfArrays</a> channels, std::vector&lt; std::vector&lt; <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html">ERStat</a> &gt; &gt; &amp;regions, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga121402b88177c336b18945dd71d96ae0">Vec2i</a> &gt; &gt; &amp;groups, std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;groups_rects, int method=<a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62">ERGROUPING_ORIENTATION_HORIZ</a>, const std::string &amp;filename=std::string(), float minProbablity=0.5)</td></tr>
<tr class="memdesc:ga6299380bbb9141488220bdee62b62cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find groups of Extremal Regions that are organized as text blocks.  <a href="../../da/d56/group__text__detect.html#ga6299380bbb9141488220bdee62b62cd1">More...</a><br /></td></tr>
<tr class="separator:ga6299380bbb9141488220bdee62b62cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga807dea4f63f6e2b59c9ac22d35e23926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga807dea4f63f6e2b59c9ac22d35e23926">cv::text::erGrouping</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> image, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> channel, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt; regions, std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;groups_rects, int method=<a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62">ERGROUPING_ORIENTATION_HORIZ</a>, const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;filename=<a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a>(), float minProbablity=(float) 0.5)</td></tr>
<tr class="separator:ga807dea4f63f6e2b59c9ac22d35e23926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a0e90a70de747b993be34ed7933ef53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga8a0e90a70de747b993be34ed7933ef53">cv::text::loadClassifierNM1</a> (const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;filename)</td></tr>
<tr class="memdesc:ga8a0e90a70de747b993be34ed7933ef53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow to implicitly load the default classifier when creating an <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html" title="Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]...">ERFilter</a> object.  <a href="../../da/d56/group__text__detect.html#ga8a0e90a70de747b993be34ed7933ef53">More...</a><br /></td></tr>
<tr class="separator:ga8a0e90a70de747b993be34ed7933ef53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7555ebd0850765e1cb09d322235cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#ga7a7555ebd0850765e1cb09d322235cf8">cv::text::loadClassifierNM2</a> (const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;filename)</td></tr>
<tr class="memdesc:ga7a7555ebd0850765e1cb09d322235cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow to implicitly load the default classifier when creating an <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html" title="Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]...">ERFilter</a> object.  <a href="../../da/d56/group__text__detect.html#ga7a7555ebd0850765e1cb09d322235cf8">More...</a><br /></td></tr>
<tr class="separator:ga7a7555ebd0850765e1cb09d322235cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40b490a66fa21eb1d89163202f69c86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/group__text__detect.html#gaa40b490a66fa21eb1d89163202f69c86">cv::text::MSERsToERStats</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> image, std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt; &amp;contours, std::vector&lt; std::vector&lt; <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html">ERStat</a> &gt; &gt; &amp;regions)</td></tr>
<tr class="memdesc:gaa40b490a66fa21eb1d89163202f69c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="../../d3/d28/classcv_1_1MSER.html" title="Maximally stable extremal region extractor. ">MSER</a> contours (vector&lt;Point&gt;) to <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html" title="The ERStat structure represents a class-specific Extremal Region (ER). ">ERStat</a> regions.  <a href="../../da/d56/group__text__detect.html#gaa40b490a66fa21eb1d89163202f69c86">More...</a><br /></td></tr>
<tr class="separator:gaa40b490a66fa21eb1d89163202f69c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2>Class-specific Extremal Regions for Scene Text Detection </h2>
<p>The scene text detection algorithm described below has been initially proposed by Lukás Neumann &amp; Jiri Matas [Neumann12]. The main idea behind Class-specific Extremal Regions is similar to the <a class="el" href="../../d3/d28/classcv_1_1MSER.html" title="Maximally stable extremal region extractor. ">MSER</a> in that suitable Extremal Regions (ERs) are selected from the whole component tree of the image. However, this technique differs from <a class="el" href="../../d3/d28/classcv_1_1MSER.html" title="Maximally stable extremal region extractor. ">MSER</a> in that selection of suitable ERs is done by a sequential classifier trained for character detection, i.e. dropping the stability requirement of MSERs and selecting class-specific (not necessarily stable) regions.</p>
<p>The component tree of an image is constructed by thresholding by an increasing value step-by-step from 0 to 255 and then linking the obtained connected components from successive levels in a hierarchy by their inclusion relation:</p>
<div class="image">
<img src="../../component_tree.png" alt="component_tree.png"/>
<div class="caption">
image</div></div>
<p> The component tree may conatain a huge number of regions even for a very simple image as shown in the previous image. This number can easily reach the order of 1 x 10\^6 regions for an average 1 Megapixel image. In order to efficiently select suitable regions among all the ERs the algorithm make use of a sequential classifier with two differentiated stages.</p>
<p>In the first stage incrementally computable descriptors (area, perimeter, bounding box, and euler number) are computed (in O(1)) for each region r and used as features for a classifier which estimates the class-conditional probability p(r|character). Only the ERs which correspond to local maximum of the probability p(r|character) are selected (if their probability is above a global limit p_min and the difference between local maximum and local minimum is greater than a delta_min value).</p>
<p>In the second stage, the ERs that passed the first stage are classified into character and non-character classes using more informative but also more computationally expensive features. (Hole area ratio, convex hull ratio, and the number of outer boundary inflexion points).</p>
<p>This ER filtering process is done in different single-channel projections of the input image in order to increase the character localization recall.</p>
<p>After the ER filtering is done on each input channel, character candidates must be grouped in high-level text blocks (i.e. words, text lines, paragraphs, ...). The opencv_text module implements two different grouping algorithms: the Exhaustive Search algorithm proposed in [Neumann11] for grouping horizontally aligned text, and the method proposed by Lluis Gomez and Dimosthenis Karatzas in [Gomez13][Gomez14] for grouping arbitrary oriented text (see erGrouping).</p>
<p>To see the text detector at work, have a look at the textdetection demo: <a href="https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/textdetection.cpp">https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/textdetection.cpp</a> </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gadb54af888e64e7371eae98f54584db3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb54af888e64e7371eae98f54584db3b">&sect;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computeNMChannels operation modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadb54af888e64e7371eae98f54584db3ba79e06bd9ad5b17411581ac430f805e66"></a>ERFILTER_NM_RGBLGrad&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggadb54af888e64e7371eae98f54584db3ba00b4e765bdc40567ad70beb7df464e06"></a>ERFILTER_NM_IHSGrad&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gac71e4c8addcf8f6dabc9b6da401d5eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac71e4c8addcf8f6dabc9b6da401d5eb9">&sect;&nbsp;</a></span>erGrouping_Modes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../da/d56/group__text__detect.html#gac71e4c8addcf8f6dabc9b6da401d5eb9">cv::text::erGrouping_Modes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../da/d56/group__text__detect.html#ga6299380bbb9141488220bdee62b62cd1" title="Find groups of Extremal Regions that are organized as text blocks. ">text::erGrouping</a> operation modes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62"></a>ERGROUPING_ORIENTATION_HORIZ&#160;</td><td class="fielddoc"><p>Exhaustive Search algorithm proposed in [Neumann11] for grouping horizontally aligned text. The algorithm models a verification function for all the possible ER sequences. The verification fuction for ER pairs consists in a set of threshold-based pairwise rules which compare measurements of two regions (height ratio, centroid angle, and region distance). The verification function for ER triplets creates a word text line estimate using Least Median-Squares fitting for a given triplet and then verifies that the estimate is valid (based on thresholds created during training). Verification functions for sequences larger than 3 are approximated by verifying that the text line parameters of all (sub)sequences of length 3 are consistent. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac71e4c8addcf8f6dabc9b6da401d5eb9aa88b048d788f8f61bcec6c478078e3c4"></a>ERGROUPING_ORIENTATION_ANY&#160;</td><td class="fielddoc"><p>Text grouping method proposed in [Gomez13][Gomez14] for grouping arbitrary oriented text. Regions are agglomerated by Single Linkage Clustering in a weighted feature space that combines proximity (x,y coordinates) and similarity measures (color, size, gradient magnitude, stroke width, etc.). SLC provides a dendrogram where each node represents a text group hypothesis. Then the algorithm finds the branches corresponding to text groups by traversing this dendrogram with a stopping rule that combines the output of a rotation invariant text group classifier and a probabilistic measure for hierarchical clustering validity assessment. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga23fdd9364be7b67d104f814dd679fcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23fdd9364be7b67d104f814dd679fcde">&sect;&nbsp;</a></span>computeNMChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::text::computeNMChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga889a09549b98223016170d9b613715de">OutputArrayOfArrays</a>&#160;</td>
          <td class="paramname"><em>_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_mode</em> = <code><a class="el" href="../../da/d56/group__text__detect.html#ggadb54af888e64e7371eae98f54584db3ba79e06bd9ad5b17411581ac430f805e66">ERFILTER_NM_RGBLGrad</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the different channels to be processed independently in the N&amp;M algorithm [Neumann12]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_src</td><td>Source image. Must be RGB CV_8UC3.</td></tr>
    <tr><td class="paramname">_channels</td><td>Output vector&lt;<a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">Mat</a>&gt; where computed channels are stored.</td></tr>
    <tr><td class="paramname">_mode</td><td>Mode of operation. Currently the only available options are: ERFILTER_NM_RGBLGrad** (used by default) and <b>ERFILTER_NM_IHSGrad</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>In N&amp;M algorithm, the combination of intensity (I), hue (H), saturation (S), and gradient magnitude channels (Grad) are used in order to obtain high localization recall. This implementation also provides an alternative combination of red (R), green (G), blue (B), lightness (L), and gradient magnitude (Grad). </p>

</div>
</div>
<a id="ga34e6b32cc3db805155ab51dcd7bc61d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34e6b32cc3db805155ab51dcd7bc61d5">&sect;&nbsp;</a></span>createERFilterNM1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;<a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a>&gt; cv::text::createERFilterNM1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thresholdDelta</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minArea</em> = <code>(float)&#160;0.00025</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxArea</em> = <code>(float)&#160;0.13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minProbability</em> = <code>(float)&#160;0.4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonMaxSuppression</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minProbabilityDiff</em> = <code>(float)&#160;0.1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Extremal Region Filter for the 1st stage classifier of N&amp;M algorithm [Neumann12]. </p>
<p>Create an Extremal Region Filter for the 1st stage classifier of N&amp;M algorithm Neumann L., Matas J.: Real-Time Scene Text Localization and Recognition, CVPR 2012</p>
<p>The component tree of the image is extracted by a threshold increased step by step from 0 to 255, incrementally computable descriptors (aspect_ratio, compactness, number of holes, and number of horizontal crossings) are computed for each ER and used as features for a classifier which estimates the class-conditional probability P(er|character). The value of P(er|character) is tracked using the inclusion relation of ER across all thresholds and only the ERs which correspond to local maximum of the probability P(er|character) are selected (if the local maximum of the probability is above a global limit pmin and the difference between local maximum and local minimum is greater than minProbabilityDiff).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>– Callback with the classifier. Default classifier can be implicitly load with function <a class="el" href="../../da/d56/group__text__detect.html#ga8a0e90a70de747b993be34ed7933ef53" title="Allow to implicitly load the default classifier when creating an ERFilter object. ...">loadClassifierNM1()</a>, e.g. from file in samples/cpp/trained_classifierNM1.xml </td></tr>
    <tr><td class="paramname">thresholdDelta</td><td>– Threshold step in subsequent thresholds when extracting the component tree </td></tr>
    <tr><td class="paramname">minArea</td><td>– The minimum area (% of image size) allowed for retreived ER’s </td></tr>
    <tr><td class="paramname">maxArea</td><td>– The maximum area (% of image size) allowed for retreived ER’s </td></tr>
    <tr><td class="paramname">minProbability</td><td>– The minimum probability P(er|character) allowed for retreived ER’s </td></tr>
    <tr><td class="paramname">nonMaxSuppression</td><td>– Whenever non-maximum suppression is done over the branch probabilities </td></tr>
    <tr><td class="paramname">minProbabilityDiff</td><td>– The minimum probability difference between local maxima and local minima ERs</td></tr>
    <tr><td class="paramname">cb</td><td>: Callback with the classifier. Default classifier can be implicitly load with function loadClassifierNM1, e.g. from file in samples/cpp/trained_classifierNM1.xml </td></tr>
    <tr><td class="paramname">thresholdDelta</td><td>: Threshold step in subsequent thresholds when extracting the component tree </td></tr>
    <tr><td class="paramname">minArea</td><td>: The minimum area (% of image size) allowed for retreived ER's </td></tr>
    <tr><td class="paramname">minArea</td><td>: The maximum area (% of image size) allowed for retreived ER's </td></tr>
    <tr><td class="paramname">minProbability</td><td>: The minimum probability P(er|character) allowed for retreived ER's </td></tr>
    <tr><td class="paramname">nonMaxSuppression</td><td>: Whenever non-maximum suppression is done over the branch probabilities </td></tr>
    <tr><td class="paramname">minProbability</td><td>: The minimum probability difference between local maxima and local minima ERs</td></tr>
  </table>
  </dd>
</dl>
<p>The component tree of the image is extracted by a threshold increased step by step from 0 to 255, incrementally computable descriptors (aspect_ratio, compactness, number of holes, and number of horizontal crossings) are computed for each ER and used as features for a classifier which estimates the class-conditional probability P(er|character). The value of P(er|character) is tracked using the inclusion relation of ER across all thresholds and only the ERs which correspond to local maximum of the probability P(er|character) are selected (if the local maximum of the probability is above a global limit pmin and the difference between local maximum and local minimum is greater than minProbabilityDiff). </p>

</div>
</div>
<a id="ga00f010f5b65cc60d1290a76807d39c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00f010f5b65cc60d1290a76807d39c95">&sect;&nbsp;</a></span>createERFilterNM2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;<a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a>&gt; cv::text::createERFilterNM2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minProbability</em> = <code>(float)&#160;0.3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Extremal Region Filter for the 2nd stage classifier of N&amp;M algorithm [Neumann12]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>: Callback with the classifier. Default classifier can be implicitly load with function loadClassifierNM2, e.g. from file in samples/cpp/trained_classifierNM2.xml </td></tr>
    <tr><td class="paramname">minProbability</td><td>: The minimum probability P(er|character) allowed for retreived ER's</td></tr>
  </table>
  </dd>
</dl>
<p>In the second stage, the ERs that passed the first stage are classified into character and non-character classes using more informative but also more computationally expensive features. The classifier uses all the features calculated in the first stage and the following additional features: hole area ratio, convex hull ratio, and number of outer inflexion points. </p>

</div>
</div>
<a id="gac4abe0243775e0d1a871a7d85fde0198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4abe0243775e0d1a871a7d85fde0198">&sect;&nbsp;</a></span>detectRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::text::detectRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>er_filter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt; <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html">ERFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>er_filter2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6299380bbb9141488220bdee62b62cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6299380bbb9141488220bdee62b62cd1">&sect;&nbsp;</a></span>erGrouping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::text::erGrouping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga606feabe3b50ab6838f1ba89727aa07a">InputArrayOfArrays</a>&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html">ERStat</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga121402b88177c336b18945dd71d96ae0">Vec2i</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups_rects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62">ERGROUPING_ORIENTATION_HORIZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minProbablity</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find groups of Extremal Regions that are organized as text blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>Original RGB or Greyscale image from wich the regions were extracted.</td></tr>
    <tr><td class="paramname">channels</td><td>Vector of single channel images CV_8UC1 from wich the regions were extracted.</td></tr>
    <tr><td class="paramname">regions</td><td>Vector of ER's retreived from the <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html" title="Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]...">ERFilter</a> algorithm from each channel.</td></tr>
    <tr><td class="paramname">groups</td><td>The output of the algorithm is stored in this parameter as set of lists of indexes to provided regions.</td></tr>
    <tr><td class="paramname">groups_rects</td><td>The output of the algorithm are stored in this parameter as list of rectangles.</td></tr>
    <tr><td class="paramname">method</td><td>Grouping method (see <a class="el" href="../../da/d56/group__text__detect.html#gac71e4c8addcf8f6dabc9b6da401d5eb9" title="text::erGrouping operation modes ">text::erGrouping_Modes</a>). Can be one of ERGROUPING_ORIENTATION_HORIZ, ERGROUPING_ORIENTATION_ANY.</td></tr>
    <tr><td class="paramname">filename</td><td>The XML or YAML file with the classifier model (e.g. samples/trained_classifier_erGrouping.xml). Only to use when grouping method is ERGROUPING_ORIENTATION_ANY.</td></tr>
    <tr><td class="paramname">minProbablity</td><td>The minimum probability for accepting a group. Only to use when grouping method is ERGROUPING_ORIENTATION_ANY. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga807dea4f63f6e2b59c9ac22d35e23926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga807dea4f63f6e2b59c9ac22d35e23926">&sect;&nbsp;</a></span>erGrouping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::text::erGrouping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups_rects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="../../da/d56/group__text__detect.html#ggac71e4c8addcf8f6dabc9b6da401d5eb9a27297f8181275dff67535f204e4bdd62">ERGROUPING_ORIENTATION_HORIZ</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code><a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>minProbablity</em> = <code>(float)&#160;0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8a0e90a70de747b993be34ed7933ef53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a0e90a70de747b993be34ed7933ef53">&sect;&nbsp;</a></span>loadClassifierNM1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;<a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a>&gt; cv::text::loadClassifierNM1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow to implicitly load the default classifier when creating an <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html" title="Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]...">ERFilter</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The XML or YAML file with the classifier model (e.g. trained_classifierNM1.xml)</td></tr>
  </table>
  </dd>
</dl>
<p>returns a pointer to <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html" title="Callback with the classifier is made a class. ">ERFilter::Callback</a>. </p>

</div>
</div>
<a id="ga7a7555ebd0850765e1cb09d322235cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7555ebd0850765e1cb09d322235cf8">&sect;&nbsp;</a></span>loadClassifierNM2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/de7/structcv_1_1Ptr.html">Ptr</a>&lt;<a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html">ERFilter::Callback</a>&gt; cv::text::loadClassifierNM2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d8f/classcv_1_1String.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow to implicitly load the default classifier when creating an <a class="el" href="../../da/def/classcv_1_1text_1_1ERFilter.html" title="Base class for 1st and 2nd stages of Neumann and Matas scene text detection algorithm [Neumann12]...">ERFilter</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The XML or YAML file with the classifier model (e.g. trained_classifierNM2.xml)</td></tr>
  </table>
  </dd>
</dl>
<p>returns a pointer to <a class="el" href="../../d0/d4f/classcv_1_1text_1_1ERFilter_1_1Callback.html" title="Callback with the classifier is made a class. ">ERFilter::Callback</a>. </p>

</div>
</div>
<a id="gaa40b490a66fa21eb1d89163202f69c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40b490a66fa21eb1d89163202f69c86">&sect;&nbsp;</a></span>MSERsToERStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::text::MSERsToERStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">Point</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>contours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html">ERStat</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="../../d3/d28/classcv_1_1MSER.html" title="Maximally stable extremal region extractor. ">MSER</a> contours (vector&lt;Point&gt;) to <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html" title="The ERStat structure represents a class-specific Extremal Region (ER). ">ERStat</a> regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Source image CV_8UC1 from which the MSERs where extracted.</td></tr>
    <tr><td class="paramname">contours</td><td>Intput vector with all the contours (vector&lt;Point&gt;).</td></tr>
    <tr><td class="paramname">regions</td><td>Output where the <a class="el" href="../../db/d20/structcv_1_1text_1_1ERStat.html" title="The ERStat structure represents a class-specific Extremal Region (ER). ">ERStat</a> regions are stored.</td></tr>
  </table>
  </dd>
</dl>
<p>It takes as input the contours provided by the OpenCV <a class="el" href="../../d3/d28/classcv_1_1MSER.html" title="Maximally stable extremal region extractor. ">MSER</a> feature detector and returns as output two vectors of ERStats. This is because MSER() output contains both MSER+ and MSER- regions in a single vector&lt;Point&gt;, the function separates them in two different vectors (this is as if the ERStats where extracted from two different channels).</p>
<p>An example of MSERsToERStats in use can be found in the text detection webcam_demo: <a href="https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/webcam_demo.cpp">https://github.com/opencv/opencv_contrib/blob/master/modules/text/samples/webcam_demo.cpp</a> </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2016 13:00:26 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
