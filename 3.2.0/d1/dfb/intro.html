<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>OpenCV: Introduction</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.2.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>OpenCV (Open Source Computer Vision Library: <a href="http://opencv.org">http://opencv.org</a>) is an open-source BSD-licensed library that includes several hundreds of computer vision algorithms. The document describes the so-called OpenCV 2.x API, which is essentially a C++ API, as opposite to the C-based OpenCV 1.x API. The latter is described in opencv1x.pdf.</p>
<p>OpenCV has a modular structure, which means that the package includes several shared or static libraries. The following modules are available:</p>
<ul>
<li><a class="el" href="../../d0/de1/group__core.html">Core functionality</a> - a compact module defining basic data structures, including the dense multi-dimensional array Mat and basic functions used by all other modules.</li>
<li><a class="el" href="../../d7/dbd/group__imgproc.html">Image processing</a> - an image processing module that includes linear and non-linear image filtering, geometrical image transformations (resize, affine and perspective warping, generic table-based remapping), color space conversion, histograms, and so on.</li>
<li><b>video</b> - a video analysis module that includes motion estimation, background subtraction, and object tracking algorithms.</li>
<li><b>calib3d</b> - basic multiple-view geometry algorithms, single and stereo camera calibration, object pose estimation, stereo correspondence algorithms, and elements of 3D reconstruction.</li>
<li><b>features2d</b> - salient feature detectors, descriptors, and descriptor matchers.</li>
<li><b>objdetect</b> - detection of objects and instances of the predefined classes (for example, faces, eyes, mugs, people, cars, and so on).</li>
<li><b>highgui</b> - an easy-to-use interface to simple UI capabilities.</li>
<li><a class="el" href="../../dd/de7/group__videoio.html">Video I/O</a> - an easy-to-use interface to video capturing and video codecs.</li>
<li><b>gpu</b> - GPU-accelerated algorithms from different OpenCV modules.</li>
<li>... some other helper modules, such as FLANN and Google test wrappers, Python bindings, and others.</li>
</ul>
<p>The further chapters of the document describe functionality of each module. But first, make sure to get familiar with the common API concepts used thoroughly in the library.</p>
<h2>API Concepts </h2>
<h3>cv Namespace</h3>
<p>All the OpenCV classes and functions are placed into the cv namespace. Therefore, to access this functionality from your code, use the cv:: specifier or using namespace cv; directive: </p><div class="fragment"><div class="line">#include &quot;opencv2/core.hpp&quot;</div><div class="line">...</div><div class="line">cv::Mat H = cv::findHomography(points1, points2, CV_RANSAC, 5);</div><div class="line">...</div></div><!-- fragment --><p> or : </p><div class="fragment"><div class="line">#include &quot;opencv2/core.hpp&quot;</div><div class="line">using namespace cv;</div><div class="line">...</div><div class="line">Mat H = findHomography(points1, points2, CV_RANSAC, 5 );</div><div class="line">...</div></div><!-- fragment --><p> Some of the current or future OpenCV external names may conflict with STL or other libraries. In this case, use explicit namespace specifiers to resolve the name conflicts: </p><div class="fragment"><div class="line">Mat a(100, 100, CV_32F);</div><div class="line">randu(a, Scalar::all(1), Scalar::all(std::rand()));</div><div class="line">cv::log(a, a);</div><div class="line">a /= std::log(2.);</div></div><!-- fragment --><h3>Automatic Memory Management</h3>
<p>OpenCV handles all the memory automatically.</p>
<p>First of all, std::vector, Mat, and other data structures used by the functions and methods have destructors that deallocate the underlying memory buffers when needed. This means that the destructors do not always deallocate the buffers as in case of Mat. They take into account possible data sharing. A destructor decrements the reference counter associated with the matrix data buffer. The buffer is deallocated if and only if the reference counter reaches zero, that is, when no other structures refer to the same buffer. Similarly, when a Mat instance is copied, no actual data is really copied. Instead, the reference counter is incremented to memorize that there is another owner of the same data. There is also the Mat::clone method that creates a full copy of the matrix data. See the example below: </p><div class="fragment"><div class="line">// create a big 8Mb matrix</div><div class="line">Mat A(1000, 1000, CV_64F);</div><div class="line"></div><div class="line">// create another header for the same matrix;</div><div class="line">// this is an instant operation, regardless of the matrix size.</div><div class="line">Mat B = A;</div><div class="line">// create another header for the 3-rd row of A; no data is copied either</div><div class="line">Mat C = B.row(3);</div><div class="line">// now create a separate copy of the matrix</div><div class="line">Mat D = B.clone();</div><div class="line">// copy the 5-th row of B to C, that is, copy the 5-th row of A</div><div class="line">// to the 3-rd row of A.</div><div class="line">B.row(5).copyTo(C);</div><div class="line">// now let A and D share the data; after that the modified version</div><div class="line">// of A is still referenced by B and C.</div><div class="line">A = D;</div><div class="line">// now make B an empty matrix (which references no memory buffers),</div><div class="line">// but the modified version of A will still be referenced by C,</div><div class="line">// despite that C is just a single row of the original A</div><div class="line">B.release();</div><div class="line"></div><div class="line">// finally, make a full copy of C. As a result, the big modified</div><div class="line">// matrix will be deallocated, since it is not referenced by anyone</div><div class="line">C = C.clone();</div></div><!-- fragment --><p> You see that the use of Mat and other basic structures is simple. But what about high-level classes or even user data types created without taking automatic memory management into account? For them, OpenCV offers the Ptr template class that is similar to std::shared_ptr from C++11. So, instead of using plain pointers: </p><div class="fragment"><div class="line">T* ptr = new T(...);</div></div><!-- fragment --><p> you can use: </p><div class="fragment"><div class="line">Ptr&lt;T&gt; ptr(new T(...));</div></div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">Ptr&lt;T&gt; ptr = makePtr&lt;T&gt;(...);</div></div><!-- fragment --><p> Ptr&lt;T&gt; encapsulates a pointer to a T instance and a reference counter associated with the pointer. See the Ptr description for details.</p>
<h3>Automatic Allocation of the Output Data</h3>
<p>OpenCV deallocates the memory automatically, as well as automatically allocates the memory for output function parameters most of the time. So, if a function has one or more input arrays (<a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv::Mat</a> instances) and some output arrays, the output arrays are automatically allocated or reallocated. The size and type of the output arrays are determined from the size and type of input arrays. If needed, the functions take extra parameters that help to figure out the output array properties.</p>
<p>Example: </p><div class="fragment"><div class="line">#include &quot;opencv2/imgproc.hpp&quot;</div><div class="line">#include &quot;opencv2/highgui.hpp&quot;</div><div class="line"></div><div class="line">using namespace cv;</div><div class="line"></div><div class="line">int main(int, char**)</div><div class="line">{</div><div class="line">    VideoCapture cap(0);</div><div class="line">    if(!cap.isOpened()) return -1;</div><div class="line"></div><div class="line">    Mat frame, edges;</div><div class="line">    namedWindow(&quot;edges&quot;,1);</div><div class="line">    for(;;)</div><div class="line">    {</div><div class="line">        cap &gt;&gt; frame;</div><div class="line">        cvtColor(frame, edges, COLOR_BGR2GRAY);</div><div class="line">        GaussianBlur(edges, edges, Size(7,7), 1.5, 1.5);</div><div class="line">        Canny(edges, edges, 0, 30, 3);</div><div class="line">        imshow(&quot;edges&quot;, edges);</div><div class="line">        if(waitKey(30) &gt;= 0) break;</div><div class="line">    }</div><div class="line">    return 0;</div><div class="line">}</div></div><!-- fragment --><p> The array frame is automatically allocated by the &gt;&gt; operator since the video frame resolution and the bit-depth is known to the video capturing module. The array edges is automatically allocated by the cvtColor function. It has the same size and the bit-depth as the input array. The number of channels is 1 because the color conversion code COLOR_BGR2GRAY is passed, which means a color to grayscale conversion. Note that frame and edges are allocated only once during the first execution of the loop body since all the next video frames have the same resolution. If you somehow change the video resolution, the arrays are automatically reallocated.</p>
<p>The key component of this technology is the Mat::create method. It takes the desired array size and type. If the array already has the specified size and type, the method does nothing. Otherwise, it releases the previously allocated data, if any (this part involves decrementing the reference counter and comparing it with zero), and then allocates a new buffer of the required size. Most functions call the Mat::create method for each output array, and so the automatic output data allocation is implemented.</p>
<p>Some notable exceptions from this scheme are <a class="el" href="../../d2/de8/group__core__array.html#ga51d768c270a1cdd3497255017c4504be" title="Copies specified channels from input arrays to the specified channels of output arrays. ">cv::mixChannels</a>, <a class="el" href="../../d1/dd6/classcv_1_1RNG.html#ad26f2b09d9868cf108e84c9814aa682d" title="Fills arrays with random numbers. ">cv::RNG::fill</a>, and a few other functions and methods. They are not able to allocate the output array, so you have to do this in advance.</p>
<h3>Saturation Arithmetics</h3>
<p>As a computer vision library, OpenCV deals a lot with image pixels that are often encoded in a compact, 8- or 16-bit per channel, form and thus have a limited value range. Furthermore, certain operations on images, like color space conversions, brightness/contrast adjustments, sharpening, complex interpolation (bi-cubic, Lanczos) can produce values out of the available range. If you just store the lowest 8 (16) bits of the result, this results in visual artifacts and may affect a further image analysis. To solve this problem, the so-called <em>saturation</em> arithmetics is used. For example, to store r, the result of an operation, to an 8-bit image, you find the nearest value within the 0..255 range:</p>
<p class="formulaDsp">
\[I(x,y)= \min ( \max (\textrm{round}(r), 0), 255)\]
</p>
<p>Similar rules are applied to 8-bit signed, 16-bit signed and unsigned types. This semantics is used everywhere in the library. In C++ code, it is done using the saturate_cast&lt;&gt; functions that resemble standard C++ cast operations. See below the implementation of the formula provided above: </p><div class="fragment"><div class="line">I.at&lt;uchar&gt;(y, x) = saturate_cast&lt;uchar&gt;(r);</div></div><!-- fragment --><p> where cv::uchar is an OpenCV 8-bit unsigned integer type. In the optimized SIMD code, such SSE2 instructions as paddusb, packuswb, and so on are used. They help achieve exactly the same behavior as in C++ code.</p>
<dl class="section note"><dt>Note</dt><dd>Saturation is not applied when the result is 32-bit integer.</dd></dl>
<h3>Fixed Pixel Types. Limited Use of Templates</h3>
<p>Templates is a great feature of C++ that enables implementation of very powerful, efficient and yet safe data structures and algorithms. However, the extensive use of templates may dramatically increase compilation time and code size. Besides, it is difficult to separate an interface and implementation when templates are used exclusively. This could be fine for basic algorithms but not good for computer vision libraries where a single algorithm may span thousands lines of code. Because of this and also to simplify development of bindings for other languages, like Python, Java, Matlab that do not have templates at all or have limited template capabilities, the current OpenCV implementation is based on polymorphism and runtime dispatching over templates. In those places where runtime dispatching would be too slow (like pixel access operators), impossible (generic Ptr&lt;&gt; implementation), or just very inconvenient (saturate_cast&lt;&gt;()) the current implementation introduces small template classes, methods, and functions. Anywhere else in the current OpenCV version the use of templates is limited.</p>
<p>Consequently, there is a limited fixed set of primitive data types the library can operate on. That is, array elements should have one of the following types:</p>
<ul>
<li>8-bit unsigned integer (uchar)</li>
<li>8-bit signed integer (schar)</li>
<li>16-bit unsigned integer (ushort)</li>
<li>16-bit signed integer (short)</li>
<li>32-bit signed integer (int)</li>
<li>32-bit floating-point number (float)</li>
<li>64-bit floating-point number (double)</li>
<li>a tuple of several elements where all elements have the same type (one of the above). An array whose elements are such tuples, are called multi-channel arrays, as opposite to the single-channel arrays, whose elements are scalar values. The maximum possible number of channels is defined by the CV_CN_MAX constant, which is currently set to 512.</li>
</ul>
<p>For these basic types, the following enumeration is applied: </p><div class="fragment"><div class="line">enum { CV_8U=0, CV_8S=1, CV_16U=2, CV_16S=3, CV_32S=4, CV_32F=5, CV_64F=6 };</div></div><!-- fragment --><p> Multi-channel (n-channel) types can be specified using the following options:</p>
<ul>
<li>CV_8UC1 ... CV_64FC4 constants (for a number of channels from 1 to 4)</li>
<li><a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga78c5506f62d99edd7e83aba259250394">CV_8UC(n)</a> ... <a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga4213eb262159eb6da4edf8c9255e8244">CV_64FC(n)</a> or <a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_8U, n)</a> ... <a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_64F, n)</a> macros when the number of channels is more than 4 or unknown at the compilation time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>CV_32FC1 == CV_32F, CV_32FC2 == <a class="el" href="../../d1/d1b/group__core__hal__interface.html#ga56e67b727727f2f9b73a4b62f0c4b2b5">CV_32FC(2)</a> == <a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(CV_32F, 2)</a></code>, and <code><a class="el" href="../../d1/d1b/group__core__hal__interface.html#gab2ebca36079fd923483abee99d7ff40d">CV_MAKETYPE(depth, n)</a> == ((depth&amp;7) + ((n-1)&lt;&lt;3)</code>`. This means that the constant type is formed from the depth, taking the lowest 3 bits, and the number of channels minus 1, taking the next <code>log2(CV_CN_MAX)</code>` bits.</dd></dl>
<p>Examples: </p><div class="fragment"><div class="line">Mat mtx(3, 3, CV_32F); // make a 3x3 floating-point matrix</div><div class="line">Mat cmtx(10, 1, CV_64FC2); // make a 10x1 2-channel floating-point</div><div class="line">                           // matrix (10-element complex vector)</div><div class="line">Mat img(Size(1920, 1080), CV_8UC3); // make a 3-channel (color) image</div><div class="line">                                    // of 1920 columns and 1080 rows.</div><div class="line">Mat grayscale(image.size(), CV_MAKETYPE(image.depth(), 1)); // make a 1-channel image of</div><div class="line">                                                            // the same size and same</div><div class="line">                                                            // channel type as img</div></div><!-- fragment --><p> Arrays with more complex elements cannot be constructed or processed using OpenCV. Furthermore, each function or method can handle only a subset of all possible array types. Usually, the more complex the algorithm is, the smaller the supported subset of formats is. See below typical examples of such limitations:</p>
<ul>
<li>The face detection algorithm only works with 8-bit grayscale or color images.</li>
<li>Linear algebra functions and most of the machine learning algorithms work with floating-point arrays only.</li>
<li>Basic functions, such as <a class="el" href="../../d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6" title="Calculates the per-element sum of two arrays or an array and a scalar. ">cv::add</a>, support all types.</li>
<li>Color space conversion functions support 8-bit unsigned, 16-bit unsigned, and 32-bit floating-point types.</li>
</ul>
<p>The subset of supported types for each function has been defined from practical needs and could be extended in future based on user requests.</p>
<h3>InputArray and OutputArray</h3>
<p>Many OpenCV functions process dense 2-dimensional or multi-dimensional numerical arrays. Usually, such functions take cppMat as parameters, but in some cases it's more convenient to use std::vector&lt;&gt; (for a point set, for example) or Matx&lt;&gt; (for 3x3 homography matrix and such). To avoid many duplicates in the API, special "proxy" classes have been introduced. The base "proxy" class is InputArray. It is used for passing read-only arrays on a function input. The derived from InputArray class OutputArray is used to specify an output array for a function. Normally, you should not care of those intermediate types (and you should not declare variables of those types explicitly) - it will all just work automatically. You can assume that instead of InputArray/OutputArray you can always use Mat, std::vector&lt;&gt;, Matx&lt;&gt;, Vec&lt;&gt; or Scalar. When a function has an optional input or output array, and you do not have or do not want one, pass <a class="el" href="../../dc/d84/group__core__basic.html#gad9287b23bba2fed753b36ef561ae7346">cv::noArray()</a>.</p>
<h3>Error Handling</h3>
<p>OpenCV uses exceptions to signal critical errors. When the input data has a correct format and belongs to the specified value range, but the algorithm cannot succeed for some reason (for example, the optimization algorithm did not converge), it returns a special error code (typically, just a boolean variable).</p>
<p>The exceptions can be instances of the <a class="el" href="../../d1/dee/classcv_1_1Exception.html" title="Class passed to an error. ">cv::Exception</a> class or its derivatives. In its turn, <a class="el" href="../../d1/dee/classcv_1_1Exception.html" title="Class passed to an error. ">cv::Exception</a> is a derivative of std::exception. So it can be gracefully handled in the code using other standard C++ library components.</p>
<p>The exception is typically thrown either using the <a class="el" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891" title="Call the error handler. ">CV_Error(errcode, description)</a> macro, or its printf-like CV_Error_(errcode, printf-spec, (printf-args)) variant, or using the <a class="el" href="../../db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b" title="Checks a condition at runtime and throws exception if it fails. ">CV_Assert(condition)</a> macro that checks the condition and throws an exception when it is not satisfied. For performance-critical code, there is <a class="el" href="../../db/de0/group__core__utils.html#gafbcb487cba05bd288dbe18c433de4f6f">CV_DbgAssert(condition)</a> that is only retained in the Debug configuration. Due to the automatic memory management, all the intermediate buffers are automatically deallocated in case of a sudden error. You only need to add a try statement to catch exceptions, if needed: : </p><div class="fragment"><div class="line">try</div><div class="line">{</div><div class="line">    ... // call OpenCV</div><div class="line">}</div><div class="line">catch( cv::Exception&amp; e )</div><div class="line">{</div><div class="line">    const char* err_msg = e.what();</div><div class="line">    std::cout &lt;&lt; &quot;exception caught: &quot; &lt;&lt; err_msg &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><h3>Multi-threading and Re-enterability</h3>
<p>The current OpenCV implementation is fully re-enterable. That is, the same function, the same <em>constant</em> method of a class instance, or the same <em>non-constant</em> method of different class instances can be called from different threads. Also, the same <a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv::Mat</a> can be used in different threads because the reference-counting operations use the architecture-specific atomic instructions. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 23 2016 13:00:24 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
